"""Project scaffolding utilities."""

from __future__ import annotations

import dataclasses
import pathlib
from typing import Any, Dict, Optional

import jinja2
import yaml

TEMPLATE_ROOT = pathlib.Path(__file__).resolve().parent / "templates"


@dataclasses.dataclass
class TemplateConfig:
    """Configuration applied when generating a lab project."""

    name: str
    description: str = "Lab project generated by labtools."
    owner: str = "Lab Team"
    runtime: str = "python"

    @staticmethod
    def load(template_path: pathlib.Path, config_path: Optional[pathlib.Path]) -> "TemplateConfig":
        data: Dict[str, Any] = {}

        default_config = template_path / "template.yml"
        if default_config.exists():
            data.update(_load_yaml(default_config))

        if config_path:
            data.update(_load_yaml(config_path))

        return TemplateConfig(**data)


def create_project(destination: pathlib.Path, template_name: str, config_path: Optional[pathlib.Path]) -> None:
    """Generate a project into the destination path using a named template."""

    if destination.exists() and any(destination.iterdir()):
        raise FileExistsError(f"Destination '{destination}' is not empty.")

    template_path = TEMPLATE_ROOT / template_name
    if not template_path.exists():
        raise FileNotFoundError(f"Template '{template_name}' not found under {TEMPLATE_ROOT}")

    config = TemplateConfig.load(template_path, config_path)
    context = dataclasses.asdict(config)

    env = jinja2.Environment(
        loader=jinja2.FileSystemLoader(str(template_path / "files")),
        autoescape=False,
        keep_trailing_newline=True,
    )

    destination.mkdir(parents=True, exist_ok=True)

    for template_file in env.list_templates():
        source = env.get_template(template_file)
        rendered = source.render(**context)

        output_path = destination / template_file
        output_path.parent.mkdir(parents=True, exist_ok=True)
        output_path.write_text(rendered, encoding="utf-8")


def _load_yaml(path: pathlib.Path) -> Dict[str, Any]:
    with path.open("r", encoding="utf-8") as handle:
        data = yaml.safe_load(handle) or {}

    if not isinstance(data, dict):
        raise ValueError(f"YAML file '{path}' must contain a mapping at the top level.")

    return data


